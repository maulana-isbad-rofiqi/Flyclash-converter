// script.js â€” FlyClash Converter PRO (full-feature)
// Author: generated by assistant for your repo
// Paste/overwrite this file in your repo and push to GitHub.
// This script builds UI if missing, parses many link formats, and generates FlyClash JS override + YAML.

/* ========== Utilities ========== */
const $ = (sel, root = document) => (root || document).querySelector(sel);
const $$ = (sel, root = document) => Array.from((root || document).querySelectorAll(sel));
const now = () => new Date().toISOString();

function safeJSON(obj) {
  try { return JSON.stringify(obj); } catch { return String(obj); }
}
function tryAtob(s) {
  try { return atob(s); } catch { return null; }
}
function isBase64(s) {
  try { return btoa(atob(s)) === s; } catch { return false; }
}
function downloadText(filename, content, type='text/plain') {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* ========== Build UI (if page is minimal) ========== */
function ensureUI() {
  // If index.html already has the advanced UI (by id "fc-root"), do nothing.
  if ($('#fc-root')) return;

  // Clear body and build modern UI
  document.title = 'FlyClash Converter â€” PRO';
  document.body.style.margin = '0';
  document.body.style.fontFamily = 'Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
  document.body.style.background = '#0f172a';
  document.body.style.color = '#e6eef8';
  document.body.innerHTML = '';

  const root = document.createElement('div');
  root.id = 'fc-root';
  root.style.maxWidth = '1200px';
  root.style.margin = '18px auto';
  root.style.padding = '18px';
  root.innerHTML = `
  <header style="display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px">
    <h1 style="margin:0;font-size:20px">FlyClash Converter â€” PRO</h1>
    <div style="font-size:12px;color:#9ca3af">Build: ${now().slice(0,19).replace('T',' ')}</div>
  </header>
  <main style="display:grid;grid-template-columns:1fr 480px;gap:16px">
    <section id="fc-left" style="background:#071233;padding:14px;border-radius:8px;">
      <label style="font-size:13px">Input links (multi-line)</label>
      <textarea id="fc-input" placeholder="Paste vless:// vmess:// trojan:// ss:// (one per line)" style="width:100%;height:260px;padding:10px;margin-top:8px;background:#031229;border:1px solid #0b1220;color:#e6eef8;border-radius:6px"></textarea>

      <div style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
        <button id="fc-generate" style="background:#0ea5e9;border:0;padding:8px 12px;border-radius:6px;color:#04212a">Generate</button>
        <button id="fc-clear" style="background:#1f2937;border:0;padding:8px 12px;border-radius:6px">Clear</button>
        <button id="fc-validate" style="background:#06b6d4;border:0;padding:8px 12px;border-radius:6px">Validate</button>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <span style="font-size:12px;color:#94a3b8">Mode</span>
          <select id="fc-mode" style="padding:6px;border-radius:6px;background:#031229;color:#e6eef8;border:1px solid #0b1220">
            <option value="auto">Auto Best Ping (recommended)</option>
            <option value="manual">Manual Select</option>
            <option value="loadbalance">Load Balance</option>
            <option value="fallback">Fallback / Failover</option>
          </select>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px">
        <div>
          <label style="font-size:12px">Interval (s)</label>
          <input id="fc-interval" type="number" min="1" value="5" style="width:100%;padding:8px;border-radius:6px;background:#031229;border:1px solid #0b1220;color:#e6eef8" />
        </div>
        <div>
          <label style="font-size:12px">Group name</label>
          <input id="fc-group" value="AUTO BEST PING" style="width:100%;padding:8px;border-radius:6px;background:#031229;border:1px solid #0b1220;color:#e6eef8" />
        </div>
      </div>

      <div style="display:flex;gap:12px;margin-top:8px;align-items:center;flex-wrap:wrap">
        <label style="display:flex;gap:6px;align-items:center"><input id="fc-skip" type="checkbox" checked/> <span style="font-size:13px">Skip Cert Verify</span></label>
        <label style="display:flex;gap:6px;align-items:center"><input id="fc-ad" type="checkbox" checked/> <span style="font-size:13px">Include Adblock</span></label>
        <label style="display:flex;gap:6px;align-items:center"><input id="fc-auto-add" type="checkbox" checked/> <span style="font-size:13px">Auto-insert group to selectors</span></label>
      </div>

      <div id="fc-lb-area" style="margin-top:10px;display:none">
        <label style="font-size:12px">Load balance ratios (comma)</label>
        <input id="fc-lb" placeholder="e.g. 50,30,20" style="width:100%;padding:8px;border-radius:6px;background:#031229;border:1px solid #0b1220;color:#e6eef8" />
      </div>

      <div style="margin-top:10px">
        <label style="font-size:12px">DNS (comma)</label>
        <input id="fc-dns" value="223.5.5.5,8.8.8.8" style="width:100%;padding:8px;border-radius:6px;background:#031229;border:1px solid #0b1220;color:#e6eef8" />
      </div>

      <div style="margin-top:10px">
        <label style="font-size:12px">(Optional) Gist token (private) â€” leave empty for anonymous</label>
        <input id="fc-token" placeholder="ghp_xxx" style="width:100%;padding:8px;border-radius:6px;background:#031229;border:1px solid #0b1220;color:#e6eef8" />
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="fc-gist" style="background:#7c3aed;border:0;padding:8px 12px;border-radius:6px;color:white">Create Gist</button>
          <a id="fc-gist-link" href="#" target="_blank" style="display:none;padding:8px 12px;background:#e2e8f0;border-radius:6px;color:#111;text-decoration:none">Open Gist</a>
        </div>
      </div>

    </section>

    <section id="fc-right" style="display:flex;flex-direction:column;gap:10px">
      <div style="background:#021129;padding:12px;border-radius:8px;height:40%">
        <label style="font-size:13px">Preview â€” JS Override</label>
        <pre id="fc-js" style="height:100%;overflow:auto;background:#061025;border-radius:6px;padding:10px;color:#bfe6ff;font-size:12px;white-space:pre-wrap"></pre>
      </div>

      <div style="background:#021129;padding:12px;border-radius:8px;height:40%">
        <label style="font-size:13px">Preview â€” Clash YAML</label>
        <pre id="fc-yaml" style="height:100%;overflow:auto;background:#ffffff;border-radius:6px;padding:10px;color:#0b1220;font-size:12px;white-space:pre-wrap"></pre>
      </div>

      <div style="background:#021129;padding:12px;border-radius:8px;height:18%;display:flex;flex-direction:column;gap:8px">
        <div style="display:flex;gap:8px">
          <button id="fc-copy-js" style="flex:1;background:#10b981;padding:8px;border-radius:6px;border:0;color:#042a17">Copy JS</button>
          <button id="fc-download-js" style="flex:1;background:#3b82f6;padding:8px;border-radius:6px;border:0;color:white">Download JS</button>
        </div>
        <div style="display:flex;gap:8px">
          <button id="fc-copy-yaml" style="flex:1;background:#f59e0b;padding:8px;border-radius:6px;border:0;color:#331000">Copy YAML</button>
          <button id="fc-download-yaml" style="flex:1;background:#ef4444;padding:8px;border-radius:6px;border:0;color:white">Download YAML</button>
        </div>
      </div>

    </section>
  </main>
  <footer style="max-width:1200px;margin:12px auto;color:#94a3b8;font-size:13px">
    <p>Notes: This is a client-side generator. For production use, host on Cloudflare Pages. For secure Gist/repo pushes, deploy the server with a secret token.</p>
  </footer>
  `;
  document.body.appendChild(root);
}

/* ========== Parsers (robust) ========== */

// parse query string into object
function parseQuery(q) {
  const out = {};
  if (!q) return out;
  q.split('&').forEach(p => {
    const idx = p.indexOf('=');
    if (idx === -1) out[decodeURIComponent(p)] = '';
    else out[decodeURIComponent(p.slice(0, idx))] = decodeURIComponent(p.slice(idx + 1));
  });
  return out;
}

// VLESS: vless://UUID@host:port?params#name
function parseVLESS(raw) {
  try {
    const src = raw.trim();
    const without = src.replace(/^vless:\/\//i, '');
    const hashIdx = without.indexOf('#');
    const name = hashIdx === -1 ? undefined : decodeURIComponent(without.slice(hashIdx + 1));
    const beforeHash = hashIdx === -1 ? without : without.slice(0, hashIdx);
    const qIdx = beforeHash.indexOf('?');
    const beforeQ = qIdx === -1 ? beforeHash : beforeHash.slice(0, qIdx);
    const qStr = qIdx === -1 ? '' : beforeHash.slice(qIdx + 1);
    const query = parseQuery(qStr);

    const atIdx = beforeQ.indexOf('@');
    const userInfo = atIdx === -1 ? '' : beforeQ.slice(0, atIdx);
    const hostport = atIdx === -1 ? beforeQ : beforeQ.slice(atIdx + 1);
    const colonIdx = hostport.lastIndexOf(':');
    const host = colonIdx === -1 ? hostport : hostport.slice(0, colonIdx);
    const port = colonIdx === -1 ? 443 : parseInt(hostport.slice(colonIdx + 1), 10);

    return {
      proto: 'vless',
      type: 'vless',
      name: name || userInfo || `${host}:${port}`,
      uuid: userInfo,
      host,
      port,
      network: query.type || 'ws',
      path: query.path || '/',
      sni: query.sni || query.host || host,
      security: query.security || 'tls',
      raw
    };
  } catch (e) {
    return { error: true, raw, message: e.message };
  }
}

// VMess: vmess://base64json OR vmess://json
function parseVMess(raw) {
  try {
    const s = raw.trim().replace(/^vmess:\/\//i, '');
    let json = null;
    if (s.startsWith('{')) json = JSON.parse(s);
    else {
      const dec = tryAtob(s);
      if (!dec) throw new Error('VMess base64 decode failed');
      json = JSON.parse(dec);
    }
    // support vnext or single
    const server = json.add || (json.vnext && json.vnext[0] && json.vnext[0].address) || '';
    const port = parseInt(json.port || (json.vnext && json.vnext[0] && json.vnext[0].port) || 443, 10);
    const uuid = json.id || json.uuid || (json.vnext && json.vnext[0] && json.vnext[0].id) || '';
    const net = json.net || json.network || 'tcp';
    const path = json.path || (json.ws && json.ws.path) || '/';
    const host = (json.host || (json.ws && json.ws.headers && (json.ws.headers.Host || json.ws.headers.host)) || json.sni) || server;
    return {
      proto: 'vmess',
      type: 'vmess',
      name: json.ps || `${server}:${port}`,
      server,
      port,
      uuid,
      network: net,
      path,
      host,
      tls: json.tls === 'tls' || json.tls === true || false,
      raw
    };
  } catch (e) {
    return { error: true, raw, message: e.message };
  }
}

// Trojan: trojan://password@host:port?params#name
function parseTrojan(raw) {
  try {
    const s = raw.trim().replace(/^trojan:\/\//i, '');
    const hashIdx = s.indexOf('#');
    const name = hashIdx === -1 ? undefined : decodeURIComponent(s.slice(hashIdx + 1));
    const beforeHash = hashIdx === -1 ? s : s.slice(0, hashIdx);
    const qIdx = beforeHash.indexOf('?');
    const beforeQ = qIdx === -1 ? beforeHash : beforeHash.slice(0, qIdx);
    const qStr = qIdx === -1 ? '' : beforeHash.slice(qIdx + 1);
    const query = parseQuery(qStr);

    const atIdx = beforeQ.indexOf('@');
    const password = atIdx === -1 ? '' : beforeQ.slice(0, atIdx);
    const hostport = atIdx === -1 ? beforeQ : beforeQ.slice(atIdx + 1);
    const colonIdx = hostport.lastIndexOf(':');
    const host = colonIdx === -1 ? hostport : hostport.slice(0, colonIdx);
    const port = colonIdx === -1 ? 443 : parseInt(hostport.slice(colonIdx + 1), 10);

    return {
      proto: 'trojan',
      type: 'trojan',
      name: name || `${host}:${port}`,
      password,
      host,
      port,
      sni: query.sni || host,
      raw
    };
  } catch (e) {
    return { error: true, raw, message: e.message };
  }
}

// Shadowsocks: ss://method:pass@host:port#name OR ss://base64
function parseSS(raw) {
  try {
    const s = raw.trim().replace(/^ss:\/\//i, '');
    // direct method:pass@host:port#name
    if (s.includes('@') && !s.startsWith('@')) {
      const hashIdx = s.indexOf('#');
      const name = hashIdx === -1 ? undefined : decodeURIComponent(s.slice(hashIdx + 1));
      const beforeHash = hashIdx === -1 ? s : s.slice(0, hashIdx);
      const atIdx = beforeHash.indexOf('@');
      const methods = beforeHash.slice(0, atIdx);
      const hostport = beforeHash.slice(atIdx + 1);
      const colonIdx = hostport.lastIndexOf(':');
      const host = colonIdx === -1 ? hostport : hostport.slice(0, colonIdx);
      const port = colonIdx === -1 ? 8388 : parseInt(hostport.slice(colonIdx + 1), 10);
      const method = methods.split(':')[0];
      const password = methods.split(':')[1] || '';
      return {
        proto: 'ss',
        type: 'shadowsocks',
        name: name || `${host}:${port}`,
        server: host,
        port,
        cipher: method,
        password,
        raw
      };
    } else {
      // base64 style
      const hashIdx = s.indexOf('#');
      const base = hashIdx === -1 ? s : s.slice(0, hashIdx);
      const decoded = tryAtob(base);
      if (!decoded) throw new Error('SS base64 decode failed');
      const atIdx = decoded.indexOf('@');
      const methods = decoded.slice(0, atIdx);
      const hostport = decoded.slice(atIdx + 1);
      const colonIdx = hostport.lastIndexOf(':');
      const host = colonIdx === -1 ? hostport : hostport.slice(0, colonIdx);
      const port = colonIdx === -1 ? 8388 : parseInt(hostport.slice(colonIdx + 1), 10);
      const method = methods.split(':')[0];
      const password = methods.split(':')[1] || '';
      return {
        proto: 'ss',
        type: 'shadowsocks',
        name: hashIdx === -1 ? `${host}:${port}` : decodeURIComponent(s.slice(hashIdx + 1)),
        server: host,
        port,
        cipher: method,
        password,
        raw
      };
    }
  } catch (e) {
    return { error: true, raw, message: e.message };
  }
}

// dispatch parser
function parseAny(line) {
  if (!line || !line.trim()) return null;
  const l = line.trim();
  if (/^vless:\/\//i.test(l)) return parseVLESS(l);
  if (/^vmess:\/\//i.test(l)) return parseVMess(l);
  if (/^trojan:\/\//i.test(l)) return parseTrojan(l);
  if (/^ss:\/\//i.test(l)) return parseSS(l);
  // try vmess base64 without prefix
  const maybe = l.replace(/^vmess:\/\//i, '');
  if (isBase64(maybe)) return parseVMess('vmess://' + maybe);
  return { error: true, raw: l, message: 'Unknown format' };
}

/* ========== Convert nodes to Clash/Clash.Meta nodes ========== */
function nodeToClash(node, opts = {}) {
  if (!node || node.error) return null;
  const skipCert = !!opts.skipCert;
  switch ((node.proto || node.type || '').toLowerCase()) {
    case 'vless':
      return {
        name: node.name,
        type: 'vless',
        server: node.host,
        port: node.port || 443,
        uuid: node.uuid || '',
        tls: true,
        'skip-cert-verify': skipCert,
        servername: node.sni || node.host,
        network: node.network || 'ws',
        'ws-opts': { path: node.path || '/', headers: node.host ? { Host: node.sni || node.host } : undefined }
      };
    case 'vmess':
      return {
        name: node.name,
        type: 'vmess',
        server: node.server,
        port: node.port || 443,
        uuid: node.uuid || '',
        alterId: node.alterId || 0,
        tls: !!node.tls,
        'skip-cert-verify': skipCert,
        network: node.network || 'ws',
        'ws-opts': node.network === 'ws' ? { path: node.path || '/', headers: node.host ? { Host: node.host } : undefined } : undefined
      };
    case 'trojan':
      return {
        name: node.name,
        type: 'trojan',
        server: node.host,
        port: node.port || 443,
        password: node.password || '',
        tls: true,
        'skip-cert-verify': skipCert,
        servername: node.sni || node.host
      };
    case 'shadowsocks':
      return {
        name: node.name,
        type: 'shadowsocks',
        server: node.server,
        port: node.port || 8388,
        cipher: node.cipher,
        password: node.password
      };
    default:
      return null;
  }
}

/* ========== Generator: JS override + YAML ========== */
function makeOverride(clashNodes, opts = {}) {
  // Prepare proxies array block
  const proxiesBlock = clashNodes.map(n => {
    // pretty JSON, but remove undefined fields
    const o = JSON.parse(JSON.stringify(n, (k, v) => (v === undefined ? undefined : v)));
    const js = JSON.stringify(o, null, 4).replace(/\n/g, '\n        ');
    return '        ' + js;
  }).join(',\n');

  // prepare proxy-group proxies names
  const proxyNames = clashNodes.map(n => n.name);

  const groupName = opts.groupName || (opts.mode === 'loadbalance' ? 'LOAD BALANCE' : 'AUTO BEST PING');

  // Build chosen group
  let groupObj = null;
  if (opts.mode === 'auto' || opts.mode === 'auto-best-ping') {
    groupObj = {
      name: groupName,
      type: 'url-test',
      url: opts.testUrl || 'https://www.gstatic.com/generate_204',
      interval: Math.max(1, Number(opts.interval) || 5),
      tolerance: opts.tolerance || 150,
      proxies: proxyNames
    };
  } else if (opts.mode === 'loadbalance' || opts.mode === 'load-balance') {
    const weights = (opts.lb || '').split(',').map(x => { const v = parseFloat(x); return isNaN(v) ? null : v; }).filter(v => v !== null);
    const obj = { name: groupName, type: 'load-balance', proxies: proxyNames };
    if (weights.length === proxyNames.length) obj.weights = weights;
    groupObj = obj;
  } else if (opts.mode === 'fallback') {
    groupObj = { name: groupName, type: 'fallback', url: opts.testUrl || 'https://www.gstatic.com/generate_204', interval: Math.max(1, Number(opts.interval) || 5), proxies: proxyNames };
  } else { // manual
    groupObj = { name: groupName, type: 'select', proxies: proxyNames };
  }

  // If autoInsert requested, add a small script later to push it into main selectors
  const autoInsertCode = opts.autoInsert ? `
    // Try insert group into common selectors
    try {
        (config['proxy-groups'] || []).forEach(g => {
            if (g.name === 'ðŸš€ èŠ‚ç‚¹é€‰æ‹©' || g.name === 'Proxy' || g.name === 'Auto') {
                g.proxies = g.proxies || [];
                if (!g.proxies.includes("${groupName}")) g.proxies.push("${groupName}");
            }
        });
    } catch(e) {}
    ` : '';

  // Adblock: small sample list (extendable)
  const adRules = (opts.adblock) ? [
    "DOMAIN-SUFFIX,ads.google.com,REJECT",
    "DOMAIN-SUFFIX,doubleclick.net,REJECT",
    "DOMAIN-KEYWORD,adservice,REJECT",
    "DOMAIN-SUFFIX,googlesyndication.com,REJECT",
    "DOMAIN-SUFFIX,adservice.google.co.id,REJECT"
  ] : [];

  const dnsNames = (opts.dns || '223.5.5.5,8.8.8.8').split(',').map(x => x.trim()).filter(Boolean);

  // Build JS override text
  const lines = [];
  lines.push('// FlyClash override generated by FlyClash Converter PRO');
  lines.push('function main(config) {');
  // dns
  lines.push('    // DNS settings');
  lines.push('    config.dns = config.dns || {};');
  lines.push('    config.dns.enable = true;');
  lines.push('    config.dns.nameserver = ' + JSON.stringify(dnsNames) + ';');
  lines.push('');
  // proxies injection
  lines.push('    // Inject proxies');
  lines.push('    if (!config.proxies) config.proxies = [];');
  lines.push(proxiesBlock ? ('    // --- PROXIES ---\n' + proxiesBlock + '\n') : '');
  // add proxies push lines (we already built objects inline, just push them)
  // proxy-groups
  lines.push('    if (!config[\"proxy-groups\"]) config[\"proxy-groups\"] = [];');
  lines.push('    // Add generated group');
  lines.push('    config[\"proxy-groups\"].push(' + JSON.stringify(groupObj, null, 4).replace(/\n/g, '\n    ') + ');');
  // auto insert
  if (autoInsertCode) lines.push(autoInsertCode);
  // adblock
  if (adRules.length) {
    lines.push('    // Adblock sample rules');
    lines.push('    config.rules = config.rules || [];');
    adRules.forEach(r => lines.push('    config.rules.push(' + JSON.stringify(r) + ');'));
    lines.push('');
  }
  lines.push('    return config;');
  lines.push('}');

  const jsText = lines.join('\n');

  // Also produce YAML (minimal)
  const yamlObj = {
    'port': 7890,
    'socks-port': 7891,
    'allow-lan': true,
    'log-level': 'info',
    dns: { enable: true, nameserver: dnsNames },
    proxies: clashNodes,
    'proxy-groups': [groupObj],
  };
  // small YAML dump (not full-proof, but ok for preview)
  function yamlDump(obj, indent = 0) {
    const pad = ' '.repeat(indent);
    if (Array.isArray(obj)) return obj.map(it => pad + '- ' + yamlDump(it, indent + 2).trim()).join('\n');
    if (typeof obj === 'object' && obj !== null) {
      return Object.entries(obj).map(([k, v]) => {
        if (v === null || v === undefined) return pad + `${k}:`;
        if (Array.isArray(v)) return pad + `${k}:\n` + yamlDump(v, indent + 2);
        if (typeof v === 'object') return pad + `${k}:\n` + yamlDump(v, indent + 2);
        return pad + `${k}: ${v}`;
      }).join('\n');
    }
    return pad + String(obj);
  }
  const yamlText = yamlDump(yamlObj);

  return { js: jsText, yaml: yamlText };
}

/* ========== Event wiring ========== */
function wireEvents() {
  const el = {
    input: $('#fc-input'),
    generate: $('#fc-generate'),
    clear: $('#fc-clear'),
    validate: $('#fc-validate'),
    jsPre: $('#fc-js'),
    yamlPre: $('#fc-yaml'),
    copyJs: $('#fc-copy-js'),
    downJs: $('#fc-download-js'),
    copyYaml: $('#fc-copy-yaml'),
    downYaml: $('#fc-download-yaml'),
    mode: $('#fc-mode'),
    interval: $('#fc-interval'),
    group: $('#fc-group'),
    skip: $('#fc-skip'),
    ad: $('#fc-ad'),
    lbArea: $('#fc-lb-area'),
    lb: $('#fc-lb'),
    dns: $('#fc-dns'),
    autoAdd: $('#fc-auto-add'),
    gistBtn: $('#fc-gist'),
    gistToken: $('#fc-token'),
    gistLink: $('#fc-gist-link'),
    validateBtn: $('#fc-validate')
  };

  // show/hide lb area
  el.mode.addEventListener('change', () => {
    if (el.mode.value === 'loadbalance' || el.mode.value === 'load-balance') el.lbArea.style.display = 'block';
    else el.lbArea.style.display = 'none';
  });

  // Validate input lines
  el.validate.addEventListener('click', () => {
    const text = el.input.value || '';
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const parsed = lines.map(l => parseAny(l) || { error:true, raw:l });
    const ok = parsed.filter(p => !p.error).length;
    alert(`Detected ${lines.length} lines. Valid: ${ok}, Invalid: ${lines.length - ok}`);
  });

  // Clear
  el.clear.addEventListener('click', () => {
    el.input.value = '';
    el.jsPre.textContent = '';
    el.yamlPre.textContent = '';
    el.gistLink.style.display = 'none';
  });

  // Generate
  el.generate.addEventListener('click', () => {
    const text = el.input.value || '';
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    if (!lines.length) return alert('Paste link VLESS/VMess/Trojan/SS dulu.');
    const parsed = lines.map(l => parseAny(l)).filter(Boolean);
    const good = parsed.filter(p => !p.error);
    const bad = parsed.filter(p => p.error);
    if (!good.length) return alert('Tidak ada link valid. Periksa format.');

    // convert nodes
    const opts = {
      mode: el.mode.value === 'auto' ? 'auto' : el.mode.value,
      interval: Number(el.interval.value) || 5,
      groupName: el.group.value || undefined,
      skipCert: !!el.skip.checked,
      adblock: !!el.ad.checked,
      lb: (el.lb.value || '').trim(),
      dns: (el.dns.value || '').trim(),
      autoInsert: !!el.autoAdd.checked,
      testUrl: 'https://www.gstatic.com/generate_204'
    };

    const clashNodes = good.map(n => nodeToClash(n, { skipCert: opts.skipCert })).filter(Boolean);
    const out = makeOverride(clashNodes, opts);
    el.jsPre.textContent = out.js;
    el.jsPre.dataset.content = out.js;
    el.yamlPre.textContent = out.yaml;
    el.yamlPre.dataset.content = out.yaml;

    // show short summary of bad entries in console
    if (bad.length) console.warn('Some entries failed to parse:', bad);
  });

  // copy / download actions
  el.copyJs.addEventListener('click', () => {
    const txt = el.jsPre.dataset.content || '';
    if (!txt) return alert('Belum ada JS. Generate dulu.');
    navigator.clipboard.writeText(txt).then(() => alert('JS Override disalin.'));
  });
  el.downJs.addEventListener('click', () => {
    const txt = el.jsPre.dataset.content || '';
    if (!txt) return alert('Belum ada JS. Generate dulu.');
    downloadText('flyclash-override.js', txt, 'application/javascript');
  });
  el.copyYaml.addEventListener('click', () => {
    const txt = el.yamlPre.dataset.content || '';
    if (!txt) return alert('Belum ada YAML. Generate dulu.');
    navigator.clipboard.writeText(txt).then(() => alert('YAML disalin.'));
  });
  el.downYaml.addEventListener('click', () => {
    const txt = el.yamlPre.dataset.content || '';
    if (!txt) return alert('Belum ada YAML. Generate dulu.');
    downloadText('clash-config.yaml', txt, 'text/yaml');
  });

  // Create Gist (client-side)
  el.gistBtn.addEventListener('click', async () => {
    const txt = el.jsPre.dataset.content || '';
    if (!txt) return alert('Belum ada JS. Generate dulu.');
    const token = (el.gistToken.value || '').trim();
    el.gistBtn.disabled = true;
    el.gistBtn.textContent = 'Creating...';
    try {
      const body = { files: { 'flyclash-override.js': { content: txt } }, public: false, description: 'FlyClash override created' };
      const headers = { 'Content-Type': 'application/json' };
      if (token) headers.Authorization = 'token ' + token;
      const r = await fetch('https://api.github.com/gists', { method: 'POST', headers, body: JSON.stringify(body) });
      const j = await r.json();
      if (j && j.html_url) {
        el.gistLink.href = j.html_url; el.gistLink.style.display = 'inline-block'; el.gistLink.textContent = 'Open Gist';
        alert('Gist created: ' + j.html_url);
      } else {
        alert('Gist creation failed. See console for details.'); console.error('Gist response', j);
      }
    } catch (e) {
      alert('Gist error: ' + e.message);
    } finally {
      el.gistBtn.disabled = false; el.gistBtn.textContent = 'Create Gist';
    }
  });

}

/* ========== Init ========== */

(function init() {
  ensureUI();
  wireEvents();
  // Expose some helpers for console debugging
  window.FlyClashPRO = { parseAny, parseVLESS, parseVMess, parseTrojan, parseSS, nodeToClash, makeOverride };
})();
